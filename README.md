 In Open3D, the common methods for building point cloud models are: [1] Open3D a-shape surface reconstruction [2] Open3D spherical rotation algorithm (BPA) 3D modeling [3] Open3D Poisson surface reconstruction 

#  Function analysis 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574476087
  ```  
  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574476087
  ```  
#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574476087
  ```  
#  III. Display of results 

 ![avatar]( 20210424085725641.png) 

>  Since there is no point cloud model under watertight and orientable conditions for the time being, there is no computing volume. I will add it when there is a model!!! The code in another blog python - VTK computing the volume and surface area of the ply format mesh model does not require the point cloud model to be watertight and orientable. 

#  IV. Experimental data 

 Link: https://pan.baidu.com/s/1mLe5X6YCsxwdHrZ6Ua8qzA Extraction code: h74h 



--------------------------------------------------------------------------------

#  First, the surface curvature 

     The greater the delta, the greater the fluctuation of the neighborhood. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 202402030957445404
  ```  


--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Calculation process 

##  2. Detailed process 

    It is known that the process of point cloud registration is to solve the rotation matrix and translation vector. Here, the objective function is: In the formula, it is the number of matching points, assuming that the least squares solution is sum, then it is the same as the centroid, that is, where: And the centroid of the point cloud is: Then make: At this time, the objective function can be rewritten as: will be decomposed into: 

  To make the minimum, it is necessary to derive and maximize, then there are: In the above formula, it is a third-order square matrix: the decomposition matrix is: let, then there is: This can be seen as a symmetric positive definite matrix. So for any third-order orthogonal square matrix, then for all third-order orthogonal square matrices, only when the determinant is close to 1 or equal to 1 (transformed so that it is completely coincident), the matrix is rotated. Then the translation matrix is:  

##  3. References 

>  LIU Yi. 3D Reconstruction of Binocular Visual Scene Based on Kinect [D]. University of Electronic Science and Technology of China, 2016. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574428941
  ```  
#  III. Display of results 

 ![avatar]( 88f6044deee446efb814849cfa5c43f0.png) 

 Initial position, position after registration  

#  IV. Test data 

 The test data is generated by MATLAB code, which is as follows: 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574428941
  ```  
#  V. Reference links 

 [1] PCL SVD分解求变换矩阵 [2] 利用SVD求得两个对应点集合的旋转矩阵R和转移矩阵t的数学推导 [3] 计算两个对应点集之间的旋转矩阵R和转移矩阵T 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

   The method is mainly used to roughly count the area occupied by airborne point clouds. The principle of the method is to divide the point cloud into a grid along the surface, and count the grid area of the points to approximately represent the area occupied by the point cloud. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 202402030957441982
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 202402030957441982
  ```  
 ![avatar]( fa1dd7ab23a74b72bc4357dcdaf6d474.png) 

#  IV. Test data 

 Link: https://pan.baidu.com/s/1qPJY2usVBWGkdaq8VNoDog extraction code: ftx5 



--------------------------------------------------------------------------------

#  Introduction to the principle 

##  1. Create a KD tree 

 ![avatar]( 20210516160551664.png) 

   A kd-tree data structure is a data structure used in computer science to organize data with several points in k-dimensional space. It is a binary search tree with other constraints. K-d trees are very useful for range searches and nearest neighbor searches. For our purposes, we usually only deal with 3-D point clouds, so all our k-d trees are 3-D. Each layer of the K-d tree uses a hyperplane perpendicular to the corresponding axis, dividing all the children along a specific dimension. At the root of the tree, all the sub-nodes will be split according to the first dimension (i.e. if the first-dimensional coordinate is less than the root, it will be in the left subtree, if it is larger than the root, then it will be obviously in the right subtree). Each layer in the tree is divided on the next dimension, returning to the first dimension once all the other dimensions have been exhausted. The most efficient way to build a k-d tree is to use a partitioning method: place the middle point at the root and everything has a smaller one-dimensional value, smaller on the left and larger on the right. Then, repeat this process on the left and right subtrees until the last tree to be partitioned consists of only one element. Figure 1 is a schematic diagram of a two-dimensional data search with k = 2. Each layer of the kd-tree is a dimension of the data, and a sub-node is used to split the dimensional data interval. The data smaller than the node value in this dimension is placed in the left subnumber, and the data larger than the node value is placed in the right subtree. Each layer of the kd-tree is separated in the next dimension of the data. When the dimensions of the data are used up, it returns to the first dimension and continues to iterate until the searched data is determined. This method reduces the time complexity to. Creating a kd-tree usually uses the median value of each dimension of the data value as the segmentation hyperplane.  

   In the process of 3D point cloud data search, KD-tree also realizes the fast retrieval of 3D point cloud data by one-dimensional hyperplane perpendicular to the point cloud and recursively dividing the space into multiple subspaces. 

##  2. Neighborhood search 

 ![avatar]( 20210516163024278.gif) 

   The image below is a demonstration of how the nearest neighbor search works.  

#  Algorithm flow 

##  1. Read the point cloud and build a KDTree 

   This is the preprocessing step for the nearest neighbor query. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433692
  ```  
##  2. Select the query point 

 The code below uses the 200th point as the query point. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433692
  ```  
##  3. K-nearest neighbor search 

   search_knn_vector_3d returns an index list of the k nearest neighbors of the query point. These adjacent points are stored in the array numpy, and all points in the numpy array are colored (rendered green [0, 1, 0]) using pcd.colors. The first index point is skipped here because it is the query point itself. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433692
  ```  
##  4. Radius neighborhood search 

   Use search_radius_vector_3d to query all points that are less than a given radius 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433692
  ```  
##  5. Mixed search 

   In addition to KNN search (search_knn_vector_3d) and RNN search (search_radius_vector_3d), Open3d also provides a hybrid search function (search_hybrid_vector_3d). It returns up to K closest neighbors that are less than a given radius from the query point. This function combines KNN and RNN search conditions and is also referred to as RKNN search in some literature. It has performance advantages in many cases and is widely used in Open3d's functions. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433692
  ```  
#  III. Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433692
  ```  
#  IV. Display of results 

 ![avatar]( 20200826165149929.png) 

#  V. Remarks 

 ![avatar]( 20210404090231393.jpg) 

   When using k-nearest neighbor search in the same point cloud, the "k" nearest neighbor points here include the queried point itself. For example, to search for 5 points closest to the black point, when "k = 5" in the parameter, the nearest neighbor points are shown in red. In fact, in the case of not including its own point, the searched points are "k-1" points in the neighborhood of that point.  



--------------------------------------------------------------------------------

#  First, the code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433035
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433035
  ```  


--------------------------------------------------------------------------------

#  First, the code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574445056
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574445056
  ```  


--------------------------------------------------------------------------------

#  First, the basis for realization 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574410843
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574410843
  ```  
 ![avatar]( 94df5fe8410a4bae8f662b9273068d07.png) 

#  IV. Relevant links 

 [1] Open3D 计算点云凸包 [2] Open3D 计算点云模型的表面积和体积 [3] python点云处理算法汇总(长期更新版) 



--------------------------------------------------------------------------------

#  I. Overview of algorithms 

   The VoxelGrid class and the ApproximateVoxelGrid class implement the voxel-based filtering method to downsample the point cloud. The octree also establishes voxels, so the octree-based voxels can also downsample the point cloud. In pclpy, the octree-based voxel downsampling is realized. There are two implementations: one is to use the octree to occupy the mean of the voxel point XYZ instead of all the points in the voxel, and the other is to use the octree to occupy the mean of the voxel XYZRGB instead of all the points in the voxel. The result of the final performance is that the point cloud obtained by using the calculation method of XYZ mean has no color information, and the point cloud calculated by using the XYZRGB mean has color, but the color change is the average of all points in the voxel RGB (detailed comments in the code). 

>  Note: This method is basically the same as ApproximateVoxelGrid, replacing the points in the voxels with the center points. The only difference is that ApproximateVoxelGrid can freely set the length, width and height of the voxels, while the octree can only be the voxels that build the cube. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574429025
  ```  
#  III. Display of results 

 ![avatar]( ceed01060f864f8da35c35aba7aef931.png) 

 (XYZ mean) voxel filtering (XYZRGB mean) voxel filtering  



--------------------------------------------------------------------------------

>  3D point cloud data, 3D deep learning 

 ![avatar]( 20181022110308642) 

  ShapeNet is a richly labeled large-scale point cloud dataset containing 55 common item categories and 513,000 3D models. 

 This is a small database containing 12,000 objects of 270 classes.  

 ![avatar]( 20181022110338786) 

  ModelNet has a total of 662 object classifications, 127,915 CAD, and ten categories of labeled orientation data. It contains three subsets: 

 ![avatar]( 20181022110201490) 

 It contains 12 rigid body classifications, each with more than 3000 instances. And contains images corresponding to each class in imageNet.  

 ![avatar]( abc-dataset.png) 

 Large 3D simulation dataset, [paper]  

 ![avatar]( 201810221153028) 

 ![avatar]( 20181022115812728) 

 Stanford computer graphics lab 3D dataset, 3D scan dataset, and another sculpture dataset   

 ![avatar]( 2018102211124392) 

  This lab provides several 3D datasets, including: 

 Princeton dataset, large scene reconstruction. Mainly used for SFM methods.  

 This lab offers 17 3D vision datasets, in addition to ShapeNet and SUN3D mentioned above, as well as: 

 ![avatar]( 20181022110733514) 

 3D shape modeling database from a single RGB image  

 related dataset 

 Add a more comprehensive summary: GitHub Tutorial 

 ![avatar]( 2018102215241256) 

  icon from easyicon.net 

 ref 1.more data:https://blog.csdn.net/wi162yyxq/article/details/69501350 2.http://www.pointclouds.org/news/2013/01/07/point-cloud-data-sets/ 



--------------------------------------------------------------------------------

